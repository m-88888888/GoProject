# 3.関数と型

### 型のキャスト
```go
// 変数aをT型にキャストする。
T(a)

var f float32 = 10
var n int = int(f)
println(n) // -> 10
```

### コンポジット型
複数のデータ型が集まって一つのデータ型を形成している

| 型の種類  | 説明  |
|---|---|
| 構造体  | 型の異なるデータ型を集めたデータ型  |
| 配列 | 同じ型のデータ型を集めて並べたデータ型 |
| スライス | 配列の一部を切り出したデータ型 |
| マップ | キーと値をマッピングさせたデータ型 |

#### コンポジット型のゼロ値

| 型  | ゼロ値  |
|---|---|
| 構造体  |  フィールドすべてゼロ地 |
| 配列 | 要素すべてゼロ値 |
| スライス | nil |
| マップ | nil |

### 型リテラル
- 型の名前と記号を組み合わせて表現される名前のない型のこと
- コンポジット型などを定義するために使う。

```go
// int型のスライスの型リテラルを使った変数定義
var ns []int
// mapの型リテラルを使った変数定義
var m map[string]int
```

### 構造体
- 型の異なるデータ型の変数を集めたデータ構造

```go
p := struct {
  name string
  age int
}{
  // 構造体の初期化
  name: "hoge",
  age: 25,
}
// .（ドット）でアクセス
print(p.name)
```

### 配列
```go
// 型と要素数で宣言
// ゼロ値で初期化
var ary [5]int

// 配列リテラルで初期化
var ary1 = [5]int{1,2,3,4,5}

// 要素数を値から推論
ary2 := [...]int{1,2,3,4,5}

// 2番目が2、100番目が0で他がゼロ値の要素数101の配列
ary3 := [...]int{2:2, 100:0}

// 要素へのアクセス
// 添字は変数でも可
fmt.Println(ary1[4])

// 長さ
fmt.Println(len(ary1))

// スライス演算
fmt.Println(ary1[1:2])
```

### スライス
- 可変長配列の代わりとなる型
- 型、要素数、容量を使ってメモリを確保する
  - 容量をあらかじめ確保することで、容量超過時の再確保を減らして速度を速めている

#### 型の宣言
```go
// ゼロ値はnil
// 要素数は書かない
var slice []int
var slice = []int{1,2,3}
slice := []int{1,2,3}

// スライスに渡した部分列はメモリ領域を渡すため、スライスの要素を変更した場合は元の配列データも修正される（参照型ってこと）
a := [3]int{1, 2, 3}
b := a[:]
fmt.Println(b) // -> [1,2,3]

b[1] = 10

fmt.Println(a) // -> [1,10,3]
```

#### 操作
```go
a := [3]int{1,2,3}
// 全要素取り出し
b := a[:]
// n番目から最後まで
c := a[2:]
// n番目からm番目まで
d := a[1:2]
// はじめからn番目まで
e := a[:2]

// make関数
// スライスの長さと容量を指定して初期化
// make(型、要素数、容量)
hoge := make([]int, 3, 10)

// append関数
// 指定したスライスの末尾にデータを追加
// append(スライス, データ1, データ2)
hoge := append(hoge, 1, 2, 3, 4, 5)
// 容量がいっぱいになった時、現在の容量を倍にして再確保する
// つまり、配列のメモリアドレスも再確保に伴って変更される

// スライスの要素のカット
// 任意の範囲を削除する
// i=削除範囲の始端インデックス、j=削除範囲の終端インデックス+1
// s = append(a[i], a[j:]...)
s := []int{0,1,2,3,4}
// -> [0,1,2,3,4]
fmt.Println(s)
// インデックスの0番目から2番目まで削除
s = append(s[:0], s[3:]...)
// -> [3,4]
fmt.Println(s)

// スライスの要素の削除
s2 := []int{0,1,2,3,4}
// インデックスの2番目を削除
s2 = append(s2[:2], s2[2+1:]...)
// -> [0,1,3,4]
fmt.Println(s2)
```

#### appendの挙動
- 容量が足りる時
  - メモリアドレスは更新されない
  - lenのみ更新される
- 容量が足りない時
  - 元のスライスの2倍の容量を確保する
  - ポインタとlenとcapが更新される

### マップ
- 他の言語のマップと同じ挙動？
- ただし、キーには「==」で比較できる型しか設定できない

```go
// 初期化
var m map[string]int
// makeで初期化
m = make(map[string]int)
// 容量の指定
m = make(map[string]int, 10)
// リテラルで初期化
m := map[string]int{"hoge":10, "fuga":100}
// 空のマップ
m := map[string]int

// 操作
// アクセス
println(m["hoge"])
// キーに値を設定
m["hoge"] = 20
// 存在を確認する
n, ok := m["hoge"]
println(n, ok)
// キーを指定して削除
delete(m, "hoge")
```

#### コンポジット型をコンポジット型の要素とすることができる
```go
// スライスの要素がスライス
var hoge [][]int
// マップの値がスライス
var m map[string][]int
// 構造体のフィールドが構造体
struct {
  A struct {
    N int
  }
}
```

### ユーザ定義型type
- `type 型名 規定型`で定義できる
- 名前をつけて新しい型を定義できる

```go
// 組み込み型
type NewInt int
// 他パッケージの型
type NewWritter io.Writter
// 型リテラル
type Person struct {
  Name string
}

// 基底型↔ユーザ定義型の相互キャストが可能
var n int = 100
m := NewInt(n)
n = int(m)
```

### 関数
- 複数の戻り値を定義することができる。

```go
// 関数名(引数, 型, ...) 戻り値 {}
func swap(x int, y int) (int, int) {
  // カンマで区切って複数の戻り値を返す
  return y,x
}
// 引数の型をまとめて定義できる
func hoge(x, y int) (int, int) {
  return x, y

// 受け取り方
// カンマで区切って受け取る
x, y := swap(10, 20)
// 省略したい場合は_「ブランク変数」を使う
x, _ := swap(10, 20)
_, y := swap(10, 20)
}
```

#### 値の入れ替え
```go
// 一時変数を使わずに変数の値を入れ替えることができる
x, y = y, x
```
### 無名関数（クロージャ）
```go
msg := "Hello, World"
func() {
  println(msg)
}()
```

### ポインタ
- 変数の格納先
- 内部でポインタを使用しているデータ型では使う必要ない。参照先をみてるから。
  - スライス
  - マップ
  - チャネル

```go
func f(xp *int){
  *xp = 100 // xのアドレスに格納
}

func main() {
  var x int
  f(&x) // xのポインタ取得
  println(x) // -> 100
}

```

ポインタを利用した値の入れ替え
```go
n, m := 10, 20
// 変数のアドレスを渡す
swap(&n, &m)
println(n, m)


func swap(x, y *int) {
  // 参照先の値を入れ替え
	*x, *y = *y, *x
}
```

### メソッド
- レシーバに紐付いた関数のこと
- Golangにおけるレシーバとは、Javaにおける`this`と似た役割
  - レシーバがその型のときに同じ名前のメソッドでも型に一致するほうが呼び出される
- メソッドがクラスに属しているのではなく、レシーバの型に対応したメソッドを書く、というイメージ
```go
type Hex int
// メソッド定義
// func (レシーバ) メソッド名 戻り値
func (h Hex) String() string {
  return fmt.Printf("%x", int(h))
}

func main() {
  var hex Hex = 100
  hex.String()
}

// メソッドの呼び出し
type T int
func (t *T) f() { println("hoge")}
func main() {
  var v T
  (&v).f() // 同じ呼び出し
  v.f() //　同じ呼び出し→ポインタを取得できるなら変数から呼び出せる（シンタックスシュガー）
}

// メソッドを式として変数に代入できる
hoge := T.f
fmt.Println(hoge(*t)) // レシーバを第1引数として渡す
```